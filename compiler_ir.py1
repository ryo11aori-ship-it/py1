@v s 'sys'
@v 星 'ast'
@v 表 'print'
@v 開 'open'
@v 読 'read'
@v 確 'isinstance'
@v 逝 'exit'
@v 書 'write'
@v 誤 'stderr'
@v 形 'format'
@v 寸 'len'
@v 裂 'splitlines'
@v 削 'strip'
@v 引 'argv'
@v 解 'parse'
@v 始 'startswith'
@v 分 'split'

# AST Types
@v 根 'Module'
@v 式 'Expr'
@v 呼 'Call'
@v 定 'Constant'
@v 二 'BinOp'
@v 足 'Add'
@v 減 'Sub'
@v 掛 'Mult'
@v 除 'Div'
@v 名 'Name'

# AST Attributes
@v 価 'value'
@v 左 'left'
@v 右 'right'
@v 算 'op'
@v 関 'func'
@v 識 'id'
@v 類 'args'
@v 体 'body'

# IR命令文字列 (全て変数化)
@v 積 'PUSH {}'
@v 加 'ADD'
@v 差 'SUB'
@v 乗 'MUL'
@v 割 'DIV'
@v 印 'PRINT'
@v 刷 'print'

# Misc
@v 改 '\n'
@v 符 'utf-8'
@v 号 'encoding'
@v モ 'r'
@v メ 'Usage: python compiler_ir.py <source_file>\n'
@v ド '$'
@v 冠 '@v'
@v 点 "'"

# 変数宣言 (Python変数名へのマッピング)
@v 辞 'D'
@v 節 'n'
@v 項 'x'
@v 道 'p'
@v 文 't'
@v 列 'L'
@v 行 'l'
@v 素 'S'
@v 身 'B'
@v 旗 'f'
@v 部 'P'
@v 頭 'H'
@v 鍵 'k'
@v 値 'v'
@v 真 'R'
@v 仮 'A'
@v 木 'T'
@v 巡 'V'
@v オ 'O'

$
m s
m 星

# 定義辞書
辞 = {}

# Visitor
d 巡(節):
 # Expr
 i 確(節, 星.式):
  巡(節.価)

 # Constant
 i 確(節, 星.定):
  表(積.形(節.価))

 # BinOp
 i 確(節, 星.二):
  # 逆ポーランド記法 (左右->演算)
  巡(節.左)
  巡(節.右)
  
  i 確(節.算, 星.足):
   表(加)
  i 確(節.算, 星.減):
   表(差)
  i 確(節.算, 星.掛):
   表(乗)
  i 確(節.算, 星.除):
   表(割)

 # Call
 i 確(節, 星.呼):
  f 項 n 節.類:
   巡(項)
  
  真 = ""
  i 確(節.関, 星.名):
   仮 = 節.関.識
   i 仮 n 辞:
    真 = 辞[仮]
   e:
    真 = 仮
  
  i 真 == 刷:
   表(印)

 # Module
 i 確(節, 星.根):
  f 文 n 節.体:
   巡(文)

# Main
i 寸(s.引) < 2:
 s.誤.書(メ)
 s.逝(1)

道 = s.引[1]
オ = {号: 符}
文 = 開(道, モ, **オ).読()
列 = 文.裂()

身 = ""
旗 = 0

f 行 n 列:
 素 = 行.削()
 i 旗:
  身 = 身 + 行 + "改"
 e:
  i 素 == "ド":
   旗 = 1
   C
  
  # 簡易パース: startswith, split をエイリアス経由で呼ぶ
  i 素.始(冠):
   部 = 素.分(点)
   i 寸(部) >= 2:
    頭 = 部[0].削()
    鍵 = 頭[-1]
    値 = 部[1]
    辞[鍵] = 値

木 = 星.解(身)
巡(木)
