@v s 'sys'
@v 星 'ast'
@v 表 'print'
@v 開 'open'
@v 読 'read'
@v 確 'isinstance'
@v 逝 'exit'
@v 書 'write'
@v 誤 'stderr'
@v 形 'format'
@v 寸 'len'
@v 裂 'splitlines'
@v 削 'strip'
@v 引 'argv'
@v 解 'parse'
@v 規 're'
@v 組 'compile'
@v 検 'match'
@v グ 'group'

# AST Types
@v 根 'Module'
@v 式 'Expr'
@v 呼 'Call'
@v 定 'Constant'
@v 二 'BinOp'
@v 足 'Add'
@v 減 'Sub'
@v 掛 'Mult'
@v 除 'Div'
@v 名 'Name'

# AST Attributes
@v 価 'value'
@v 左 'left'
@v 右 'right'
@v 算 'op'
@v 関 'func'
@v Ｉ 'id'
@v 類 'args'
@v 体 'body'

# IR Strings (ここに追加！)
@v 積む 'PUSH {}'
@v 足す 'ADD'
@v 引く 'SUB'
@v 描く 'MUL'
@v 割る 'DIV'
@v 印字 'PRINT'
@v 印名 'print'

# Misc
@v 改 '\n'
@v 符 'utf-8'
@v 号 'encoding'
@v 読モード 'r'
@v メ 'Usage: python compiler_ir.py <source_file>\n'
@v ド '$'
@v 定義頭 '@v'
@v 引用符 "'"

# 変数宣言
@v 辞 'D'
@v 節 'node'
@v 項 'item'
@v 道 'path'
@v 文 'text'
@v 列 'lines'
@v 行 'line'
@v 素 'sline'
@v 身 'body'
@v 旗 'flag'
@v 分 'parts'
@v 頭 'header'
@v 鍵 'k'
@v 値 'v'
@v 真 'real'
@v 仮 'alias'
@v 木 'tree'
@v 巡 'visit'
@v オ 'opts'

$
m s
m 星

# 定義辞書
辞 = {}

# Visitor関数
d 巡(節):
 # --- 式 (Expr) ---
 i 確(節, 星.式):
  巡(節.価)

 # --- 定数 (Constant) ---
 i 確(節, 星.定):
  表(積む.形(節.価))

 # --- 二項演算 (BinOp) ---
 i 確(節, 星.二):
  # 逆ポーランド記法順
  巡(節.左)
  巡(節.右)
  
  i 確(節.算, 星.足):
   表(足す)
  i 確(節.算, 星.減):
   表(引く)
  i 確(節.算, 星.掛):
   表(描く)
  i 確(節.算, 星.除):
   表(割る)

 # --- 関数呼び出し (Call) ---
 i 確(節, 星.呼):
  f 項 n 節.類:
   巡(項)
  
  真 = ""
  i 確(節.関, 星.名):
   仮 = 節.関.Ｉ
   i 仮 n 辞:
    真 = 辞[仮]
   e:
    真 = 仮
  
  i 真 == 印名:
   表(印字)

 # --- モジュール (Module) ---
 i 確(節, 星.根):
  f 文 n 節.体:
   巡(文)

# ---------------------------------------------------------
# Main
# ---------------------------------------------------------
i 寸(s.引) < 2:
 s.誤.書(メ)
 s.逝(1)

道 = s.引[1]
# encoding=utf-8 を **kwargs で渡す (識別子長制限の回避)
オ = {号: 符}
文 = 開(道, 読モード, **オ).読()
列 = 文.裂()

身 = ""
旗 = 0

f 行 n 列:
 素 = 行.削()
 i 旗:
  身 = 身 + 行 + "改"
 e:
  i 素 == "ド":
   旗 = 1
   C
  
  # 簡易パース: split("'") を使う
  # @v K 'V' -> ["@v K ", "V", ""]
  i 素.startswith(定義頭):
   分 = 素.split(引用符)
   i 寸(分) >= 2:
    頭 = 分[0].削()
    # 末尾の1文字がキー
    鍵 = 頭[-1]
    値 = 分[1]
    辞[鍵] = 値

# AST解析
木 = 星.解(身)

# コンパイル実行
巡(木)
