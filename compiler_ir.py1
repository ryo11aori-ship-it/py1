@v s 'sys'
@v 星 'ast'
@v 表 'print'
@v 開 'open'
@v 読 'read'
@v 確 'isinstance'
@v 逝 'exit'
@v 書 'write'
@v 誤 'stderr'
@v 形 'format'
@v 寸 'len'
@v 裂 'splitlines'
@v 削 'strip'
@v 引 'argv'
@v 解 'parse'
@v 規 're'
@v 組 'compile'
@v 検 'match'
@v グ 'group'

# AST Types
@v 根 'Module'
@v 式 'Expr'
@v 呼 'Call'
@v 定 'Constant'
@v 二 'BinOp'
@v 足 'Add'
@v 減 'Sub'
@v 掛 'Mult'
@v 除 'Div'
@v 名 'Name'

# AST Attributes
@v 価 'value'
@v 左 'left'
@v 右 'right'
@v 算 'op'
@v 関 'func'
@v Ｉ 'id'
@v 類 'args'
@v 体 'body'

# Misc
@v 改 '\n'
@v 符 'utf-8'
@v 読モード 'r'
@v メ 'Usage: python compiler_ir.py <source_file>\n'
@v ド '$'
# 正規表現（空白は[ \t]で表現）
@v 則 '^@v[ \t]+(.)[ \t]+\x27([^\x27]*)\x27[ \t]*$'

$
m s
m 星
m 規

# 定義辞書
辞 = {}

# Visitor関数
d 巡(節):
 # --- 式 (Expr) ---
 i 確(節, 星.式):
  巡(節.価)

 # --- 定数 (Constant) ---
 i 確(節, 星.定):
  表("PUSH {}".形(節.価))

 # --- 二項演算 (BinOp) ---
 i 確(節, 星.二):
  # 逆ポーランド記法順 (左右を先に処理)
  巡(節.左)
  巡(節.右)
  
  i 確(節.算, 星.足):
   表("ADD")
  i 確(節.算, 星.減):
   表("SUB")
  i 確(節.算, 星.掛):
   表("MUL")
  i 確(節.算, 星.除):
   表("DIV")

 # --- 関数呼び出し (Call) ---
 i 確(節, 星.呼):
  # 引数を処理
  f 項 n 節.類:
   巡(項)
  
  # 関数名を解決 ("print" かどうか)
  真 = ""
  i 確(節.関, 星.名):
   仮 = 節.関.Ｉ
   i 仮 n 辞:
    真 = 辞[仮]
   e:
    真 = 仮
  
  i 真 == "print":
   表("PRINT")

 # --- モジュール (Module) ---
 i 確(節, 星.根):
  f 文 n 節.体:
   巡(文)

# ---------------------------------------------------------
# Main
# ---------------------------------------------------------
i 寸(s.引) < 2:
 s.誤.書(メ)
 s.逝(1)

道 = s.引[1]
文 = 開(道, "読モード", 号="符").読()
列 = 文.裂()

身 = ""
旗 = 0
型 = 規.組("則")

f 行 n 列:
 素 = 行.削()
 i 旗:
  身 = 身 + 行 + "改"
 e:
  i 素 == "ド":
   旗 = 1
   C
  
  # @v 定義を簡易パースして辞書に入れる
  当 = 型.検(素)
  i 当:
   鍵 = 当.グ(1)
   値 = 当.グ(2)
   辞[鍵] = 値

# AST解析
木 = 星.解(身)

# コンパイル実行
巡(木)
